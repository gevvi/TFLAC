# Лабораторная работа 1  
**Тема:** Разработка пользовательского интерфейса (GUI) для языкового процессора  
- **Цель:** Разработать приложение – текстовый редактор.
---


## Основные функции  

### Файл  
- **Создать**  
  Создает новый файл или проект.  
- **Открыть**  
  Открывает существующий файл или проект из файловой системы.  
- **Сохранить**  
  Сохраняет текущий файл.  
- **Сохранить как**  
  Сохраняет текущий файл с новым именем или в новом месте.  
- **Выход**  
  Закрывает IDE.  

### Правка  
- **Отменить**  
  Отменяет последнее действие.  
- **Повторить**  
  Повторяет отмененное действие.  
- **Вырезать**  
  Удаляет выделенный текст или элемент и помещает его в буфер обмена.  
- **Копировать**  
  Копирует выделенный текст или элемент в буфер обмена.  
- **Вставить**  
  Вставляет содержимое буфера обмена в текущее место курсора.  
- **Удалить**  
  Удаляет выделенный текст или элемент без помещения в буфер обмена.  
- **Выделить все**  
  Выделяет весь текст или элемент в текущем окне или документе.  

## Дополнительныйе задания
- **Изменение размеров текста в окне редактирования и окне вывода результатов.**
- **Интерфейс с вкладками, позволяющий одновременно работать с несколькими текстами (для окна редактирования).**
- **Выбор языка интерфейса приложения (интернационализация).**
- **Нумерация строк в окне редактирования текста.**
- **Открытие файла при перетаскивании иконки в окно программы.**
- **Наличие строки состояния для отображения текущей информации о состоянии работы приложения.**
- **Базовая подсветка синтаксиса в окне редактирования.**
- **Интерфейс с вкладками, позволяющий работать с разными модулями программы (для окна вывода результатов)**
- **Отображение ошибок в окне вывода результатов в виде таблицы.**
- **Горячие клавиши для быстрых команд.**
---

# Лабораторная работа 2  
**Тема:** Разработка лексического анализатора (сканера)
 **Вариант 36. Объявление вещественной константы с инициализацией в СУБД PostgreSQL**
 **Вводные данные:**
 - DECLARE VAT CONSTANT NUMERIC := 0.1;
   
---
 **Цель работы:** Изучить назначение лексического анализатора. Спроектировать алгоритм и выполнить программную реализацию сканера.
- В соответствии с вариантом задания необходимо:
- Спроектировать диаграмму состояний сканера (примеры диаграмм представлены в прикрепленных файлах).
- Разработать лексический анализатор, позволяющий выделить в тексте лексемы, иные символы считать недопустимыми (выводить ошибку).
- Встроить сканер в ранее разработанный интерфейс текстового редактора. Учесть, что текст для разбора может состоять из множества строк.
---
![image](https://github.com/user-attachments/assets/a6e7435c-72e3-4f5c-8b89-c430005d06f1)
рис. 1 диаграмма сканера
![image](https://github.com/user-attachments/assets/9d27773f-2ea4-4e15-a6d1-d9a7651b203a)
рис. 2 работа сканера

# Лабораторная работа 3
**Тема:** Разработка синтаксического анализатора (парсера)
**Цель работы:** Изучить назначение синтаксического анализатора. Спроектировать алгоритм и выполнить программную реализацию парсера.
 **Вариант 36. Объявление вещественной константы с инициализацией в СУБД PostgreSQL**
 **Вводные данные:**
 - DECLARE VAT CONSTANT NUMERIC := 0.1;
---
### Требования к программе:
-    Результатом анализа правильной строки является вывод сообщения об отсутствии ошибок.
-    Если анализируемая строка содержит ошибки, то выводятся сообщения о них, неверный фрагмент (символ) и его местоположение.
-    В окне вывода результатов выводится количество ошибок.
### **Грамматика:**
1.	‹Start› → ‘DECLARE’‹SP1›
2.	‹SP1› → ‘ ’‹LT›
3.	‹LT› → ‹ letter›‹LT›
4.	‹LT› → ‹ letter›‹DG›
5.	‹LT› → ‹ letter›‹DG›
6.	‹LT› → ‹ letter›‹SP2›
7.	‹DG› → ‹digit›‹DG›
8.	‹DG› → ‹digit›‹LT›
9.	‹DG› → ‹digit›‹SP2›
10.	‹SP2› → ‘ ’‹CNT›
11.	‹CNT› → ‘CONSTANT’‹SP3›
12.	‹SP3› → ‘ ’‹NUM›
13.	‹NUM › → ‘NUMERIC’‹SP4›
14.	‹SP4› → ‘ ’‹AST›
15.	‹AST› → ‘:=’‹SP5›
16.	‹SP5› → ‘ ’‹DG1›
17.	‹DG1› → ‹digit›‹DG1›
18.	‹DG1› → ‘.’‹DG2›
19.	‹DG2› → ‹digit›‹DG2›
20.	‹DG2› → ‹digit›‹END›
21.	‹End› → ‘;’
- ‹digit› → “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9”
- ‹letter› → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”

![image](https://github.com/user-attachments/assets/87c36315-1ad7-4b6c-8322-cf4f38f7fa0c)
рис. 3 работа парсера

---

# Лабораторная работа 4
**Цель работы:** Реализовать алгоритм нейтрализации синтаксических ошибок и дополнить им программную реализацию парсера.
**Задание:** Реализовать алгоритм синтаксического анализа с нейтрализацией ошибок (метод Айронса). 

---

# Лабораторная работа 5
**Тема:** Включение семантики в анализатор. Создание внутренней формы представления программы. Цель работы: Дополнить анализатор, разработанный в рамках лабораторных работ, этапом формирования внутренней формы представления программы.

**1 вариант.** В качестве внутренней формы представления программы выберем польскую инверсную запись (ПОЛИЗ). Эта форма представления наглядна и достаточно проста для последующей интерпретации, которая может быть выполнена с использованием стека.

**Задание:**

Реализовать в текстовом редакторе поиск лексических и синтаксических ошибок для грамматики G[]. Реализовать данную КС-граммматику методом рекурсивного спуска:
E → TA
A → ε | + TA | - TA
T → ОВ
В → ε | *ОВ | /ОВ
О → num | (E)
num → digit {digit}
Реализовать алгоритм записи арифметических выражений в ПОЛИЗ и алгоритм вычисления выражений в ПОЛИЗ.
изображение

![image](https://github.com/user-attachments/assets/392d6710-e39f-44b9-b50b-e8a7657f2296)

рис.7 Пример с ошибкой

![image](https://github.com/user-attachments/assets/755ff160-6b7f-457c-b4a6-a3fac1015b7e)

рис.8 Верно решенный пример

---

# Лабораторная работа 6

**Тема:** Реализация алгоритма поиска подстрок с помощью регулярных выражений.

**Цель:** Реализовать алгоритм поиска в тексте подстрок, соответствующих заданным регулярным выражениям Задания:

(21). Построить РВ, описывающее целые числа и числа с плавающей точкой (разделитель запятая).
РВ:"-?\d+(?:,\d+)?"

(1). Построить РВ, описывающее стандартный формат юзернейма (содержит цифры, строчные буквы, символы - и _, имеет длину от 5 до 20 знаков).
РВ:"\b[a-z0-9_-]{5,20}\b"

(17). Построить РВ, описывающее широту (учесть диапазон корректных значений).
РВ:"^[-+]?(?:90(?:\.0+)?|(?:[1-8]?\d(?:\.\d+)?))"


![image](https://github.com/user-attachments/assets/dd26b58f-07c9-4172-855f-dfbee287d496)

рис.9 Пример нахождения числа

![image](https://github.com/user-attachments/assets/667bc443-f84e-48b2-8374-873cf3f23765)

рис.10 Пример нахождения юзернейма

![image](https://github.com/user-attachments/assets/c339f56e-754a-4d00-90ae-11683dcafd5d)

рис.11 Пример нахождения широты

---

**Доп.Задание**
![image](https://github.com/user-attachments/assets/57fd318a-549f-41e0-84f2-9502fafcbb71)

рис.12 Граф автомата

---

# Лабораторная работа 7

**Тема лабораторной работы:** Преобразование и анализ кода с использованием Clang и LLVM.

**Цель работы:** Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

**Задание:** 

1. Установить Clang и LLVM;

2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

4. Построить граф потока управления (CFG) для оптимизированной программы;
  
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

![image](https://github.com/user-attachments/assets/9fc8b18a-aedf-4711-a662-9eaca765b9b3)

рис.13 Установка необходимых пакетов

![image](https://github.com/user-attachments/assets/ca646957-c20e-4f91-9722-71b7f7bb1774)

рис.14 Файла main.c

![image](https://github.com/user-attachments/assets/2d0041d5-bb08-44b0-bec5-6f1085a192c5)

рис.15 Получение AST Содержимое 

![image](https://github.com/user-attachments/assets/00dfee0e-ee92-4f8b-8627-78022ad1f996)

рис.16 Генерация LLVM IR

![image](https://github.com/user-attachments/assets/add14b1a-381e-47b3-960f-eabe92150243)

рис.17 Создание main_O0.ll 

![image](https://github.com/user-attachments/assets/652cfac0-a2a3-45d6-9bbf-0e63d3f7380a)

рис.18 Создание main_O2.ll

![image](https://github.com/user-attachments/assets/0306289d-a191-497a-a473-e24df581a940)

рис.19 Сравнение двух файлов

![image](https://github.com/user-attachments/assets/ea747c86-9337-4073-b023-35c3b65cb18f)

рис.20 Команда для генерации .dot-файлов CFG для функций 

![image](https://github.com/user-attachments/assets/39a50542-5122-44f6-a8b3-cc75e3e5e80b)


рис.21 Команда для установки библиотеки Graphviz

![image](https://github.com/user-attachments/assets/a3b584ed-90c4-4289-babe-5b42b9c5d02e)

рис.22 main.ll

![image](https://github.com/user-attachments/assets/0bc8b62e-73fb-4563-a7df-5698e3247d83)

рис.23 xdg-open cfg_main.png

![image](https://github.com/user-attachments/assets/7dfb7f5b-9b28-4165-afb2-c3ff39ba34c4)

рис.24 xdg-open cfg_square.png

## Ответы на контрольные вопросы
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это компилятор для C, C++ и Objective-C, часть LLVM. Он преобразует исходный код в машинный или промежуточный (IR), выполняя препроцессинг, анализ и оптимизацию.  

### 2. Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная платформа для разработки компиляторов, использующая универсальное промежуточное представление (IR) для оптимизации и генерации машинного кода. В современных компиляторах (Clang, Rust, Swift) LLVM отвечает за анализ, оптимизацию и поддержку разных архитектур процессоров.  

### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST отражает структуру исходного кода в виде дерева с узлами (операторы, выражения, объявления), сохраняя высокоуровневую семантику языка. LLVM IR — это низкоуровневое линейное представление, близкое к машинному коду, оптимизированное для анализа и преобразований (например, циклов или арифметики).  
Ключевое отличие: AST зависит от языка (C++, Rust и т.д.), а LLVM IR — универсален и используется для кросс-языковой оптимизации и генерации кода под разные процессоры.  

### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление (IR) нужно, чтобы отделить анализ исходного кода от генерации машинного кода, упрощая поддержку новых языков и архитектур. Оно позволяет применять универсальные оптимизации до привязки к конкретному процессору. 

### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
**alloca** в LLVM IR выделяет память в стеке функции под локальные переменные и возвращает указатель на неё. Используется для хранения адресуемых данных. Автоматически освобождается при завершении функции, аналогично обычным стековым переменным в C.  

### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода делает программу быстрее и компактнее, удаляя лишние операции и эффективнее используя ресурсы процессора. Главные задачи — ускорение вычислений, уменьшение размера кода и адаптация под конкретное оборудование. Без неё программы работали бы медленнее и тратили больше памяти.  

### 7. Что такое SSA-форма и почему она важна при оптимизации программ?  
SSA-форма (Static Single Assignment) — это представление программы, где каждая переменная инициализируется лишь единожды, что делает зависимости между данными явными и однозначными.  
Ключевая польза:  
Позволяет компилятору легко отслеживать поток данных, упрощая такие оптимизации, как удаление общих подвыражений и продвижение констант.  
Особенно полезна для анализа и преобразования циклов, где важно точно определять изменяемые переменные.  

### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
Граф потока управления (CFG) — это визуальное представление структуры программы в виде связанных блоков кода, где каждый блок содержит последовательность инструкций, а стрелки между ними показывают возможные пути выполнения. Такой граф помогает компилятору анализировать и оптимизировать код, выявляя недостижимые участки, избыточные условия и потенциальные точки ветвления. Благодаря CFG можно эффективно применять оптимизации, связанные с анализом циклов, предсказанием переходов и распределением ресурсов.

### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
В LLVM IR арифметические операции записываются как инструкции с явным указанием типа, например:  
%res = add i32 %a, %b.  
Каждая операция создаёт новое значение в SSA-форме, что упрощает анализ и оптимизацию кода.
Для умножения,сложения,вычитания и деления используются mul,add,sub,sdiv, а типы данных (как i32) всегда указываются явно, например: %sum = mul i32 %x, %y.  

### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR являются самостоятельными единицами оптимизации, поскольку их изолированная структура позволяет применять преобразования локально, не анализируя всю программу. Это даёт возможность эффективно выполнять как внутрипроцедурные оптимизации, так и межпроцедурные (анализируя взаимодействия между функциями). Такой подход значительно ускоряет процесс компиляции и улучшает качество оптимизаций.  

### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
Короткая функция в LLVM IR, вызываемая единожды, обычно подставляется на месте вызова и затем удаляется. Это устраняет накладные расходы на вызов.  

### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
Использование LLVM IR и CFG даёт ключевые преимущества для автоматических оптимизаций по сравнению с анализом исходного C-кода:  
1. Абстракция от языка — IR унифицирует разные языки (C, C++, Rust и др.), позволяя применять общие оптимизации без привязки к синтаксису.  
2. Точный контроль потока — CFG явно показывает ветвления и циклы, упрощая анализ достижимости и удаление мёртвого кода.  
3. Низкоуровневые возможности — IR ближе к машинному коду, что позволяет оптимизировать даже «неочевидные» случаи (например, замену деления на сдвиги).   
Пример: На C компилятору сложно доказать, что цикл for (int i=0; i<10; i++) всегда выполнится 10 раз, а в IR это сразу видно в CFG и SSA-форме.


---

# Лабораторная работа 8
**Тема лабораторной работы:** Реализация метода рекурсивного спуска для синтаксического анализа.

**Цель работы:** Разработать для грамматики алгоритм синтаксического анализа на основе метода рекурсивного спуска.

**Задание:** В соответствии с вариантом для заданной грамматики необходимо разработать и реализовать алгоритм синтаксического анализа на основе метода рекурсивного спуска.

**Вариант 22**

Для грамматики G[expression] разработать и реализовать алгоритм
анализа на основе метода рекурсивного спуска.
G[expression]:
1. expression := multExpression | powExpression | expression ('+'|'-') multExpression | expression ('+'|'-') powExpression
2. multExpression := ID | multExpression ('*'|'/') ID
3. powExpression := ID '^' powExpression | ID
ID – идентификатор Б{Б|Ц}, Б – {a, b, c, ...z, A, B, …, Z}, NUM – {0, 1, …, 9}

![image](https://github.com/user-attachments/assets/a9e7bd4e-1e12-4b12-b94a-cb1b747b05b3)

рис.25 Пример работы программы


---

**Доп.Задание**

Реализовать для своего варианта задания в данной лабораторной работе алгоритм лексического анализа (лексемная декомпозиция и поиск лексических ошибок).

Диаграмма сканера:

![image](https://github.com/user-attachments/assets/88d28a45-be0d-4c44-89a7-1a1d622f344c)

рис.26 Диаграмма сканера

Тестовые примеры

![image](https://github.com/user-attachments/assets/3f73af64-f13a-4368-9866-f8faf8d37f8a)

рис.27 Пример работы сканера с корректным вводом

![image](https://github.com/user-attachments/assets/362a1618-59cd-4e32-bd21-410a793d598a)

рис.28 Пример работы сканера с недопустимыми символами
